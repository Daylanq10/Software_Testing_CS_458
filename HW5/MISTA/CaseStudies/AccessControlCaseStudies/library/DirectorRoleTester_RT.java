//Test code generated by ISTA

package com.library.test.software.modeltest;

import com.library.bo.book.Book;
import com.library.bo.user.Borrower;
import com.library.bo.user.Personnel;
import com.library.bo.user.BorrowerAccount;
import com.library.bo.user.PersonnelAccount;
import com.library.bo.user.User;
import com.library.dao.BookDAO;
import com.library.dao.dto.BookDTO;
import com.library.dao.dto.spec.DTO;
import com.library.security.impl.LibrarySecurityModel;
import com.library.security.impl.context.ContextManager;
import com.library.security.model.context.Context;
import com.library.service.BookService;
import com.library.service.BorrowerAccountService;
import com.library.service.PersonnelAccountService;
import com.library.service.UserService;
import com.library.service.exception.BSException;
import com.library.service.exception.SecuritPolicyViolationException;
import com.library.service.exception.UndefinedSecuritPolicyException;
import java.sql.SQLException;
import java.util.Collection;

public class DirectorRoleTester_RT{

	private DirectorRole directorrole;
	
	public void setUp() {
	   try {
	         bookService = BookService.getInstance();
	         bookDAO = BookDAO.getInstance();
	         bookDAO.clearDatabase("books");
	         borrowerAccountService = BorrowerAccountService.getInstance();
	         personnelAccountService = PersonnelAccountService.getInstance();
	 
	         UserService userService = UserService.getInstance();
	 
	         director = userService.logUser("tata", "Yube1", UserService.PERSONNEL_LOGIN_MODE);
	         personnel = userService.logUser("juju", "JI14one!", UserService.PERSONNEL_LOGIN_MODE);
	         borrower = userService.logUser("bobo", "B14me", UserService.BORROWER_LOGIN_MODE);
	         borrowerAccount = ((Borrower) borrower.getRole()).getBorrowerAccount();
	         personnelAccount = ((Personnel) personnel.getRole()).getPersonnelAccount();
	         
	         borrower4Test = userService.logUser("tyty", "Tata", UserService.BORROWER_LOGIN_MODE);
	         borrower4Account = ((Borrower) borrower4Test.getRole()).getBorrowerAccount();
	         personnel4Test = userService.logUser("tftf", "titiopop", UserService.PERSONNEL_LOGIN_MODE);
	         personnel4Account = ((Personnel) personnel4Test.getRole()).getPersonnelAccount();
	             
	          BookDTO book1 = new BookDTO();
	          book1.setTitle(bookAvailableKey);
	          book1.setAuthor("James Cooper");
	          book1.setPub_year(2002);
	          book1.setState(BookDTO.AVAILABLE_STATE);
	          bookDAO.insert(book1);
	 
	          BookDTO book2= new BookDTO();
	          book2.setTitle(bookBorrowedKey);
	          book2.setAuthor("William Stallings");
	          book2.setPub_year(2000);
	          book2.setState(BookDTO.BORROWED_STATE);
	          bookDAO.insert(book2);
	          ContextManager.doCalculateContext = false;
	         }catch (SQLException e) {
	         }catch (BSException e) {
	         }
	  }

	public void test1_1_1_1() throws Exception {
		System.out.println("Test case 1_1_1_1");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitFixBook(bookAvailableKey);;
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitDeliverBook(bookAvailableKey);;
	}

	public void test2_1_1_2() throws Exception {
		System.out.println("Test case 2_1_1_2");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitFixBook(bookAvailableKey);;
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedDeliverBookOnWorking(bookAvailableKey);;
	}

	public void test3_1_1_3() throws Exception {
		System.out.println("Test case 3_1_1_3");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitFixBook(bookAvailableKey);;
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedDeliverBookOnWorking(bookAvailableKey);;
	}

	public void test4_1_1_4() throws Exception {
		System.out.println("Test case 4_1_1_4");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitFixBook(bookAvailableKey);;
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedGiveBack(bookBorrowedKey);;
	}

	public void test5_1_1_5() throws Exception {
		System.out.println("Test case 5_1_1_5");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitFixBook(bookAvailableKey);;
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doUndefinedGiveBack(bookBorrowedKey);;
	}

	public void test6_1_1_6() throws Exception {
		System.out.println("Test case 6_1_1_6");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doPermitFixBook(bookAvailableKey);;
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedGiveBack(bookBorrowedKey);;
	}

	public void test7_1_2() throws Exception {
		System.out.println("Test case 7_1_2");
		setUp();
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedFixBookOnWorking(bookAvailableKey);;
	}

	public void test8_1_3() throws Exception {
		System.out.println("Test case 8_1_3");
		setUp();
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedFixBookOnWorking(bookAvailableKey);;
	}

	public void test9_1_4() throws Exception {
		System.out.println("Test case 9_1_4");
		setUp();
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedReserve(bookAvailableKey);;
	}

	public void test10_1_5() throws Exception {
		System.out.println("Test case 10_1_5");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doUndefinedReserve(bookAvailableKey);;
	}

	public void test11_1_6() throws Exception {
		System.out.println("Test case 11_1_6");
		setUp();
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedReserve(bookAvailableKey);;
	}

	public void test12_1_7() throws Exception {
		System.out.println("Test case 12_1_7");
		setUp();
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedBorrow(bookAvailableKey);;
	}

	public void test13_1_8() throws Exception {
		System.out.println("Test case 13_1_8");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doUndefinedBorrow(bookAvailableKey);;
	}

	public void test14_1_9() throws Exception {
		System.out.println("Test case 14_1_9");
		setUp();
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedBorrow(bookAvailableKey);;
	}

	public void test15_1_10() throws Exception {
		System.out.println("Test case 15_1_10");
		setUp();
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedGiveBack(bookBorrowedKey);;
	}

	public void test16_1_11() throws Exception {
		System.out.println("Test case 16_1_11");
		setUp();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doUndefinedGiveBack(bookBorrowedKey);;
	}

	public void test17_1_12() throws Exception {
		System.out.println("Test case 17_1_12");
		setUp();
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedGiveBack(bookBorrowedKey);;
	}

	public void test18_2_1() throws Exception {
		System.out.println("Test case 18_2_1");
		setUp2();
		LibrarySecurityModel.DEFAULT_CONTEXT = new Context("DEFAULT");
  ContextManager.currentContext = LibrarySecurityModel.DEFAULT_CONTEXT;
		doProhibitManageAccessPersonnelAccount(true);;
	}

	public void test19_2_2() throws Exception {
		System.out.println("Test case 19_2_2");
		setUp2();
		ContextManager.currentContext = ContextManager.holidays;
		doProhibitManageAccessPersonnelAccount(false);;
	}

	public void test20_2_3() throws Exception {
		System.out.println("Test case 20_2_3");
		setUp2();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doProhibitManageAccessPersonnelAccount(false);;
	}

	public void test21_2_4() throws Exception {
		System.out.println("Test case 21_2_4");
		setUp2();
		ContextManager.currentContext = ContextManager.workingday;
		doProhibitManageAccessPersonnelAccount(false);;
	}

	public void test22_2_5() throws Exception {
		System.out.println("Test case 22_2_5");
		setUp2();
		LibrarySecurityModel.DEFAULT_CONTEXT = new Context("DEFAULT");
  ContextManager.currentContext = LibrarySecurityModel.DEFAULT_CONTEXT;
		doProhibitCreateBorrowerAccount(true);;
	}

	public void test23_2_6() throws Exception {
		System.out.println("Test case 23_2_6");
		setUp2();
		ContextManager.currentContext = ContextManager.holidays;
		doProhibitCreateBorrowerAccount(false);;
	}

	public void test24_2_7() throws Exception {
		System.out.println("Test case 24_2_7");
		setUp2();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doProhibitCreateBorrowerAccount(false);;
	}

	public void test25_2_8() throws Exception {
		System.out.println("Test case 25_2_8");
		setUp2();
		ContextManager.currentContext = ContextManager.workingday;
		doProhibitCreateBorrowerAccount(false);;
	}

	public void test26_2_9() throws Exception {
		System.out.println("Test case 26_2_9");
		setUp2();
		LibrarySecurityModel.DEFAULT_CONTEXT = new Context("DEFAULT");
  ContextManager.currentContext = LibrarySecurityModel.DEFAULT_CONTEXT;
		doProhibitModifyBorrowerAccount(true);;
	}

	public void test27_2_10() throws Exception {
		System.out.println("Test case 27_2_10");
		setUp2();
		ContextManager.currentContext = ContextManager.holidays;
		doProhibitModifyBorrowerAccount(false);;
	}

	public void test28_2_11() throws Exception {
		System.out.println("Test case 28_2_11");
		setUp2();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doProhibitModifyBorrowerAccount(false);;
	}

	public void test29_2_12() throws Exception {
		System.out.println("Test case 29_2_12");
		setUp2();
		ContextManager.currentContext = ContextManager.workingday;
		doProhibitModifyBorrowerAccount(false);;
	}

	public void test30_2_13() throws Exception {
		System.out.println("Test case 30_2_13");
		setUp2();
		LibrarySecurityModel.DEFAULT_CONTEXT = new Context("DEFAULT");
  ContextManager.currentContext = LibrarySecurityModel.DEFAULT_CONTEXT;
		doPermitedConsultBorrowerAccount();;
	}

	public void test31_2_14() throws Exception {
		System.out.println("Test case 31_2_14");
		setUp2();
		ContextManager.currentContext = ContextManager.holidays;
		doUndefinedConsultBorrowerAccount();;
	}

	public void test32_2_15() throws Exception {
		System.out.println("Test case 32_2_15");
		setUp2();
		ContextManager.currentContext = ContextManager.maintenanceDay;
		doUndefinedConsultBorrowerAccount();;
	}

	public void test33_2_16() throws Exception {
		System.out.println("Test case 33_2_16");
		setUp2();
		ContextManager.currentContext = ContextManager.workingday;
		doUndefinedConsultBorrowerAccount();;
	}

	public void testAll() throws Exception {
		test1_1_1_1();
		test2_1_1_2();
		test3_1_1_3();
		test4_1_1_4();
		test5_1_1_5();
		test6_1_1_6();
		test7_1_2();
		test8_1_3();
		test9_1_4();
		test10_1_5();
		test11_1_6();
		test12_1_7();
		test13_1_8();
		test14_1_9();
		test15_1_10();
		test16_1_11();
		test17_1_12();
		test18_2_1();
		test19_2_2();
		test20_2_3();
		test21_2_4();
		test22_2_5();
		test23_2_6();
		test24_2_7();
		test25_2_8();
		test26_2_9();
		test27_2_10();
		test28_2_11();
		test29_2_12();
		test30_2_13();
		test31_2_14();
		test32_2_15();
		test33_2_16();
	}


	     private BookService bookService;
	     private BookDAO bookDAO;
	     public User director, borrower, personnel;
	     private User personnel4Test, borrower4Test;
	     public Book book1, book2;
	     
	     private final String bookAvailableKey = "Software Testing";
	     private final String bookBorrowedKey = "Computer Networks";
	     
	     private BorrowerAccount borrowerAccount, borrower4Account;
	     private BorrowerAccountService borrowerAccountService;
	     private PersonnelAccount personnelAccount, personnel4Account;
	     private PersonnelAccountService personnelAccountService;
	
	      private Book findBookByTitle(String title) throws BSException {
	               Collection<Book> result = bookService.findBookByKeyword(title);
	           return result.iterator().next();
	     }
	
	     public void doPermitFixBook(String title) {
	              try{
	                  Book book = findBookByTitle(title);
	                  bookService.bookDamaged(director, book);
	                  assertTrue(book.isDamaged());
	                  Collection<DTO> bookDtos = bookDAO.seachBooksByKeyword(title);
	                   Book bookReturned = new Book(bookDtos.iterator().next());
	                  assertTrue(bookReturned.isDamaged());
	              } catch (UndefinedSecuritPolicyException e) {
	                    fail("Permitted book damage undefined");
	              } catch (SecuritPolicyViolationException e) {
	                    fail("Permitted book damage not allowed");
	              } catch (BSException e){
	              } catch (SQLException sqle) {   }
	 
	              try {
	                  Book book = findBookByTitle(title);
	                  bookService.fixBook(director, book);
	                  assertTrue(book.getCurrentStateString().equals(Book.BEINGFIXED));
	                  Collection<DTO> bookDtos = bookDAO.seachBooksByKeyword(title);
	                  Book bookReturned = new Book(bookDtos.iterator().next());
	                  assertTrue(bookReturned.getCurrentStateString().equals(Book.BEINGFIXED));
	               } catch (UndefinedSecuritPolicyException e) {
	                   fail("permitted book fix not definedd");
	               } catch (SecuritPolicyViolationException e) {
	                   fail("permitted book fix not allowed");
	               } catch (BSException e) {
	               } catch (SQLException sqle1) {}
	            
	              try {
	                     Book book = findBookByTitle(title);
	                     bookService.bookRepaired(director, book);
	                     Collection<DTO> bookDtos = bookDAO.seachBooksByKeyword(title);
	                     Book bookReturned = new Book(bookDtos.iterator().next());
	                     assertTrue(!bookReturned.isDamaged());
	               } catch (UndefinedSecuritPolicyException e) {
	                   fail("permitted book repair not definedd");
	                } catch (SecuritPolicyViolationException e) {
	                      fail("Permitted book repair not allowed");
	               } catch (BSException e) {
	               } catch (SQLException sqle2) {}
	   }
	
	  public void doPermitDeliverBook(String title) {
	  try {
	         Book book = findBookByTitle(title);
	         bookService.deliverBook(director, book);
	         assertTrue(book.getCurrentStateString().equals(Book.AVAILABLE));
	         Collection<DTO> bookDtos = bookDAO.seachBooksByKeyword(title);
	         Book bookReturned = new Book(bookDtos.iterator().next());
	         assertTrue(bookReturned.getCurrentStateString().equals(Book.AVAILABLE));
	         } catch (UndefinedSecuritPolicyException e) {
	          fail("Permitted book deliver not defined");
	         } catch (SecuritPolicyViolationException e) {
	          fail("Permitted book deliver not allowed");
	         } catch (BSException e) {
	         } catch (SQLException sqle) {   }
	      }
	
	   public void doUndefinedDeliverBookOnWorking(String title) {
	      LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;                    
	      try{              Book book = findBookByTitle(title);
	                bookService.bookDamaged(director, book);
	                assertTrue(book.isDamaged());
	             } catch (UndefinedSecuritPolicyException e) {
	             } catch (SecuritPolicyViolationException e) {
	             } catch (BSException e) {} 
	            try {               Book book = findBookByTitle(title);
	                bookService.fixBook(director, book);
	                assertTrue(book.getCurrentStateString().equals(Book.BEINGFIXED));
	             } catch (UndefinedSecuritPolicyException e) {
	             } catch (SecuritPolicyViolationException e) {
	             } catch (BSException e) {}
	            try {                 Book book = findBookByTitle(title);
	                bookService.bookRepaired(director, book);
	                assertTrue(!book.isDamaged());
	             } catch (UndefinedSecuritPolicyException e) {
	             } catch (SecuritPolicyViolationException e) {
	             } catch (BSException e) { } 
	             try {          Book book = findBookByTitle(title); 
	                  bookService.deliverBook(director, book);
	                  fail("Undefined Deliver book is allowed");
	              } catch (UndefinedSecuritPolicyException e) {
	                      // pass
	              } catch (SecuritPolicyViolationException e) {
	                  fail("Undefined Deliver book is prohibited");
	              } catch (BSException e1) {  }
	 }
	
	public void doUndefinedFixBookOnWorking(String title) {
	      LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;       
	         try { 
	          
	          Book book = findBookByTitle(title);
	          bookService.bookDamaged(director, book);
	          Collection<DTO> bookDtos = bookDAO.seachBooksByKeyword(title);
	       Book bookReturned = new Book(bookDtos.iterator().next());
	       assertTrue(bookReturned.isDamaged());
	       
	         } catch (SecuritPolicyViolationException spv1) {
	      } catch (BSException e) {
	      } catch (SQLException sqle1) {
	      }
	      
	       try {  
	        Book book = findBookByTitle(title);
	        bookService.fixBook(director, book);
	        fail("Undefined Book Fixed is allowed");
	        } catch (UndefinedSecuritPolicyException e) {
	           // pass
	        } catch (SecuritPolicyViolationException svp2) {
	        fail("Undefined Book Fixed is prohibited");
	        } catch (BSException e1) {        }
	}        
	
	 public void doProhibitedFixBookWhenBorrowed(String title) {
	                       
	             try {
	              Book book = findBookByTitle(title);
	              bookService.fixBook(director, book);
	              fail ("Prohibited Fix book is allowed on borrowed book");
	               } catch (SecuritPolicyViolationException e) {
	                try {
	                Collection<DTO> bookDtos = bookDAO.seachBooksByKeyword(title);
	          Book bookReturned = new Book(bookDtos.iterator().next());
	          assertTrue(!bookReturned.isDamaged());
	               }catch (SQLException sqle) {
	      }
	          } catch (BSException e) {
	    }
	  }
	
	 public void doPermitedConsultBorrowerAccount() {    
	              try {
	               BorrowerAccount borrowerAccountResult = borrowerAccountService.consultBorrowerAccount(borrower4Test, director);
	               assertEquals(borrowerAccountResult, borrower4Account);
	               } catch (UndefinedSecuritPolicyException e) {
	                fail("Permited consult undefined");
	               } catch (SecuritPolicyViolationException e) {
	                fail("Permited consult not allowed");
	              } catch (BSException e) {  } 
	  }
	
	
	public void doUndefinedConsultBorrowerAccount() {
	      try {
	       LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;
	          borrowerAccountService.consultBorrowerAccount(borrower4Test, director);
	          fail("Borrower account creation is allowed");
	       } catch (UndefinedSecuritPolicyException e) {
	       } catch (SecuritPolicyViolationException e) {
	          fail("Undefined Borrower account creation is prohibited");
	       } catch (BSException e) {} 
	 }
	
	
	public void doProhibitCreateBorrowerAccount(boolean isProhibition) {                 
	             try {
	              LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;
	              borrowerAccountService.createBorrowerAccount(borrower4Test, borrower4Account, director);
	              fail("Borrower account creation is allowed ");
	               } catch (UndefinedSecuritPolicyException e) {
	                     if (isProhibition) 
	                         fail("Prohibited Borrower account creation is undefined ");
	               } catch (SecuritPolicyViolationException e) {
	                     if (!isProhibition) 
	                           fail("Undefined Borrower account creation is prohibited ");
	               } catch (BSException e) {}
	  }
	
	public void doProhibitModifyBorrowerAccount (boolean isProhibition) {
	              try {
	              LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;
	               borrowerAccountService.updateBorrowerAccount(borrower, borrowerAccount, director); 
	               fail("Borrower account modification is allowed");
	               } catch (UndefinedSecuritPolicyException e) {
	                     if (isProhibition) 
	                        fail("Prohibited Borrower account modification is undefined ");
	              } catch (SecuritPolicyViolationException e) {
	                 if (!isProhibition) 
	                 fail("Undefined Borrower account modification is prohibited ");
	              } catch (BSException e) { }
	}
	
	public void doProhibitManageAccessPersonnelAccount(boolean isProhibition) {
	         LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;
	              try {
	                       personnelAccountService.updatePersonnelAccount(personnel, personnelAccount, director);
	                       fail("Personnel account update is allowed");
	               } catch (UndefinedSecuritPolicyException e) {
	                     if (isProhibition) 
	                        fail("Prohibited Borrower account update is undefined ");
	                  } catch (SecuritPolicyViolationException e) {
	                     if (!isProhibition) 
	                        fail("Undefined Borrower account update is prohibited ");
	                  } catch (BSException e) {}
	   
	               try {
	                       personnelAccountService.deletePersonnelAccount(personnel, personnelAccount, director);
	                       fail("Personnel account delete is allowed");
	               } catch (UndefinedSecuritPolicyException e) {
	                     if (isProhibition) 
	                        fail("Prohibited Borrower account delete is undefined ");
	               } catch (SecuritPolicyViolationException e){ 
	                     if (!isProhibition) 
	                        fail("Undefined Borrower account delete is prohibited ");
	               } catch (BSException e) {}
	     
	              try {
	                       personnelAccountService.createPersonnelAccount(personnel4Test, personnel4Account, director);
	                       fail("Personnel account creation is allowed");
	               } catch (UndefinedSecuritPolicyException e) {
	                     if (isProhibition) 
	                        fail("Prohibited Borrower account creation is undefined ");
	               } catch (SecuritPolicyViolationException e) {                 
	                     if (!isProhibition) 
	                        fail("Undefined Borrower account creation is prohibited ");
	              } catch (BSException e) {  }
	 }
	
	public void doUndefinedReserve(String title) {
	            try {
	                 LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;
	                 Book book = findBookByTitle(title);
	                 bookService.reserveBook(director, book);
	                  fail("Undefined reserve is alllowed");
	             } catch (UndefinedSecuritPolicyException e) {
	                  // pass
	             } catch (SecuritPolicyViolationException e) {
	                  fail("Undefined reserve is prohibited");
	             } catch (BSException e) {}
	}
	
	public void doUndefinedBorrow(String title) {
	            try {
	              LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;
	                 Book book = findBookByTitle(title);
	                 bookService.borrowBook(director, book);
	                   fail("Undefined borrow allowed.");
	             } catch (UndefinedSecuritPolicyException e) {
	                  // pass
	             } catch (SecuritPolicyViolationException e) {
	                  fail("Undefined borrow is prohibited");
	             } catch (BSException e) {          }
	}
	
	public void doUndefinedGiveBack(String title) {
	        LibrarySecurityModel.DEFAULT_CONTEXT = ContextManager.currentContext;     
	            try {                
	                  Book book = findBookByTitle(title);
	                  bookService.giveBackBook(director, book);
	                  fail("Prohibited give back allowed");
	            } catch (UndefinedSecuritPolicyException e) {
	                  // pass
	            } catch (SecuritPolicyViolationException svp2) {
	                  fail("Undefined giveback is prohibited");
	            } catch (BSException e1) { }
	} 
	
	
	public static void main(String[] args) throws Exception {
		 new DirectorRoleTester_RT().testAll();
	}

}
